#!/usr/bin/env python
# coding: utf-8

# Last updated: 30 Sep 2024
# 
# This is a copy of what I'm trying to do with optimized memory v0, but I want to use the same distances for mantle grids as in Mantle layering.ipynb. I think there is no reason for the resulting plots to be different if we split the layers into sublayers in this way, and sum up the integrals at the end. After all, the underlying grid points are the same and the same conditions are imposed to select them.
# 
# 

# The size of distances_squared is determined by the size of the 3D grid generated by np.meshgrid, which in turn is based on the length of the coordinates array.
# 
# Hereâ€™s how it works:
# 
#     coordinates is a 1D array of length grid_count_crust, which is 640 in this case.
#     
# 
#     np.meshgrid(coordinates, coordinates, coordinates) creates three 3D grids: x_coordinates, y_coordinates, and z_coordinates. Each of these grids has a shape of (640, 640, 640) because the grid spans 640 points along each of the three dimensions (x, y, and z).
#     
# 
#     distances_squared is calculated by squaring each element of x_coordinates, y_coordinates, and z_coordinates and adding them together. Since each of the coordinate grids has a shape of (640, 640, 640), the resulting distances_squared array will also have the same shape.
# 
# Thus, the size (or shape) of distances_squared is (640, 640, 640), which is a 3D array containing the squared distances of all the points in the grid from the origin.

# So the x, y and z coordinates contain the whole grid, and now crust_grid is an array that contains triplets (x, y, z) for all the points in the crust. Great! Now we want to select the indices for the other layers. My hope is that if we make them thin enough, everything will work. 
# 
# I am doing this manually for now, just to see if it works.

# In[1]:


import numpy as np
import matplotlib.pyplot as plt
import sys
print("imports successful")

grid_count_mantle = 400 # would need 637.1 for 20 km spacing
#320 for 40 km spacing
#285 for 45 km spacing
#215 for 60km spacing
#160 for 80km spacing
coordinates = np.linspace(-6371, 6371, grid_count_mantle)
grid_1d_size_mantle = coordinates[1]-coordinates[0]
grid_1d_size_crust = grid_1d_size_mantle

# Generate the grid coordinates using meshgrid
x_coordinates, y_coordinates, z_coordinates = np.meshgrid(coordinates, coordinates, coordinates)

# Calculate the distance of each point from the origin using vectorized operations
distances_squared = x_coordinates**2 + y_coordinates**2 + z_coordinates**2


# In[2]:


# Find indices where distance is less than or equal to the radius squared
crust_indices = np.logical_and(6350**2 < distances_squared, distances_squared <= 6371**2)

# Extract valid coordinates using boolean indexing
crust_grid = np.stack((x_coordinates[crust_indices], y_coordinates[crust_indices], z_coordinates[crust_indices]), axis=-1)

print("crust grid created successfully")


# In[3]:


CLM_indices = np.logical_and(6196**2 < distances_squared, distances_squared <= 6350**2)
CLM_grid = np.stack((x_coordinates[CLM_indices], y_coordinates[CLM_indices], z_coordinates[CLM_indices]), axis=-1)


# In[4]:


#DM is between 4202 amd 6196
#a's are just limits of the mini layers to constrain the radius

a0 = 4202
a1 = 4300
a2 = 4400
a3 = 4500
a4 = 4600
a5 = 4700
a6 = 4800
a7 = 4900
a8 = 5000
a9 = 5100
a10 = 5200
a11 = 5300
a12 = 5400
a13 = 5500
a14 = 5600
a15 = 5700
a16 = 5800
a17 = 5900
a18 = 6100
a19 = 6196

a_values = np.array([a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19])

# Initialize an empty object array to hold the DM grids
DM_grids = np.empty(len(a_values) - 1, dtype=object)
DM_indices_array = np.empty(len(a_values) - 1, dtype=object)

for i in range(len(a_values) - 1):
    DM_indices = np.logical_and(a_values[i]**2 < distances_squared, distances_squared <= a_values[i + 1]**2)
    try:
        # Attempt to create the DM_grid
        DM_grid = np.stack((x_coordinates[DM_indices], y_coordinates[DM_indices], z_coordinates[DM_indices]), axis=-1)
        
        # Store the DM_grid and DM_indices in the object arrays
        DM_grids[i] = DM_grid
        DM_indices_array[i] = DM_indices
        
        print(f"DM{i+1} grid done, limits: {a_values[i]} , {a_values[i + 1]}")
    
    except MemoryError:
        # Catch memory errors and print a message
        print(f"MemoryError encountered while creating DM{i+1} grid with limits: {a_values[i]} , {a_values[i + 1]}")




# This worked quite well, let's see if we can create the ones for EM as well. It should be fine, given that DM was the chonkiest one

# In[5]:


#EM is between 3480 amd 4202

b0 = 3480
b1 = 3600
b2 = 3700
b3 = 3800
b4 = 3900
b5 = 4000
b6 = 4100
b7 = 4202


b_values = np.array([b0, b1, b2, b3, b4, b5, b6, b7])

# Initialize an empty object array to hold the DM grids
EM_grids = np.empty(len(b_values) - 1, dtype=object)
EM_indices_array = np.empty(len(b_values) - 1, dtype=object)

for i in range(len(b_values) - 1):
    EM_indices = np.logical_and(b_values[i]**2 < distances_squared, distances_squared <= b_values[i + 1]**2)
    try:
        # Attempt to create the DM_grid
        EM_grid = np.stack((x_coordinates[EM_indices], y_coordinates[EM_indices], z_coordinates[EM_indices]), axis=-1)
        
        # Store the DM_grid and DM_indices in the object arrays
        EM_grids[i] = EM_grid
        EM_indices_array[i] = EM_indices
        
        print(f"EM{i+1} grid done, limits: {b_values[i]} , {b_values[i + 1]}")
    
    except MemoryError:
        # Catch memory errors and print a message
        print(f"MemoryError encountered while creating EM{i+1} grid with limits: {b_values[i]} , {b_values[i + 1]}")


# Ok, we have all the grids! I don't know why this takes up less memory, i even have less memory now because I repartitioned my laptop to get windows as well so I have even less memory available. I will ask chatgpt about this

# I didn't make it very clear to me why the difference in memory handling is so significant, I feel like chunking it like this or making one big array should occupy rouglhy the same memory, but anyway. I want to print the sizes of the arrays of arrays 

# In[6]:


total_memory = DM_grids.nbytes
print(f"Total memory occupied by DM_grids: {total_memory} bytes")


# The following few cells have been copied exactly from the Mantle layering.ipynb script:
# 

# In[7]:


print("setting densities and abundances")
# Define the parameter sets

# Placeholder definitions for IDE recognition
A_Th_c = A_U_c = A_Th_CLM = A_U_CLM = A_Th_DM1 = A_U_DM1 = A_Th_DM2 = A_U_DM2 = A_Th_EM = A_U_EM = 0

low_abundances = {
    "A_Th_c": 5 * (10**(-6)),
    "A_U_c": 1 * (10**(-6)),
    "A_Th_CLM": 53 * (10**(-9)),
    "A_U_CLM": 13 * (10**(-9)),
    "A_Th_DM": 17.52 * (10**(-9)),
    "A_U_DM": 6.4 * (10**(-9)),
    "A_Th_EM": 90 * (10**(-9)),
    "A_U_EM": 15 * (10**(-9))
}

mid_abundances = {
    "A_Th_c": 5 * (10**(-6)),
    "A_U_c": 1 * (10**(-6)),
    "A_Th_CLM": 147 * (10**(-9)),
    "A_U_CLM": 33 * (10**(-9)),
    "A_Th_DM": 21.9 * (10**(-9)),
    "A_U_DM": 8 * (10**(-9)),
    "A_Th_EM": 147 * (10**(-9)),
    "A_U_EM": 33 * (10**(-9))
}

high_abundances = {
    "A_Th_c": 5 * (10**(-6)),
    "A_U_c": 1 * (10**(-6)),
    "A_Th_CLM": 427 * (10**(-9)),
    "A_U_CLM": 83 * (10**(-9)),
    "A_Th_DM": 26.28 * (10**(-9)),
    "A_U_DM": 9.6 * (10**(-9)),
    "A_Th_EM": 221 * (10**(-9)),
    "A_U_EM": 57 * (10**(-9))
}

# Function to select the parameter set
def select_abundances(abundance_set):
    globals().update(abundance_set)

# Choose the desired parameter set by name
abundances = mid_abundances  # Change to mid_abundances or high_abundances as needed
select_abundances(abundances)



rho_c = 2.7
rho_CLM = 3.3 #g/cm^3 probably
rho_DM = 3.3
rho_EM = 3.3
print("densities and abundances set successfully")

#we have pretty much everything to compute things separately!
# compute for crust
#set position of SNO+

print("setting detector position")

SNO_r = np.array([0, 0, 6369])
# function to calculate relative distance to SNO+ from points in earth grid


# In[8]:


def calc_relative_dist(points_array):
    # Calculate the Euclidean distance using vectorized operations
    relative_distances = np.linalg.norm(points_array - SNO_r, axis=1)
    
    print("   ")
    print("Computed relative distances from Earth grid points to SNO+")
    print("   ")
    
    return relative_distances


#define Delta function for an array of points and energies
#inputs: appropriate deltam _ij^2, energy array [MeV], points array
#relative distance calculated in km, hence Delta scaled up by a factor of 1000 to account for m-km conversion

def Delta_ij(energy_array, points_array, delta_m_ij_squared):
    # Calculate relative distances
    relative_distance_array = calc_relative_dist(points_array)

    # Reshape energy_array to perform element-wise division
    energy_array_reshaped = energy_array.reshape(-1, 1)

    # Calculate Delta using vectorized operations
    Delta = (1.27 * delta_m_ij_squared * relative_distance_array * 1000) / (energy_array_reshaped)

    return Delta


# In[9]:


def P_ee_full_optimized(energy_array, points_array, theta_12, theta_13, delta_m_21_squared):
    
    #P_ee = np.empty((len(energy_array), len(points_array))) # np.empty more efficient
    #than np.zeros or whatever
    #might not need this at all though
    relative_distance_array = calc_relative_dist(points_array)
    
    Delta_31 = Delta_ij(energy_array, points_array, delta_m_31_squared)
    print("Delta_31 computed successfully")
    Delta_12 = Delta_ij(energy_array, points_array, delta_m_21_squared)
    print("Delta_12 computed successfully")

    A = (np.cos(theta_13))**4 * (np.sin(2 * theta_12))**2
    B = np.sin(2 * theta_13)**2

    sin_squared_Delta_31 = np.sin(Delta_31) ** 2
    sin_squared_Delta_12 = np.sin(Delta_12) ** 2
    
    print("values computed successfully")

    P_ee = 1 - (A * sin_squared_Delta_12 + B * sin_squared_Delta_31)
    print("P_ee computed successfully")
    
    return P_ee


# In[10]:


#set standard oscillation parameters
print("setting standard oscillation parameters")

theta_12 = 0.5903 #rad
theta_23 = 0.8430 #rad
theta_13 = 0.1503 #rad

delta_m_21_squared = 7.39 * 10**(-5) #eV^2
delta_m_32_squared = 2.449 * 10**(-3) #eV^2
delta_m_31_squared = delta_m_32_squared
print("defining energy array")
energy_array = np.linspace(1.81, 3.31, 30)


# In[11]:


## optimized definition of integral, optimized P_ee
def integral_over_positions_Th_U(points_array, energy_array, grid_1d_size, theta_12, delta_m_21_squared, A_Th, A_U, rho):
    dV = grid_1d_size**3
    
    relative_distance_array = calc_relative_dist(points_array)
    print("Relative distance array computed successfully")
    P_ee_array = P_ee_full_optimized(energy_array, points_array, theta_12, theta_13, delta_m_21_squared)
    print("P_ee_array computed successfully")

    # Compute sum_Th
    sum_Th = np.sum(P_ee_array * ((A_Th * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    
    print("sum_Th computed successfully")
    
    # Compute sum_U
    sum_U = np.sum(P_ee_array * ((A_U * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    print("sum_U computed successfully")

    return sum_Th, sum_U


# We have defined everything that needed defining, now we got to the part where we actually have to compute integrals; the crust and CLM parts will be the same:

# In[12]:


print("computing integral values for standard oscillation paramaters (crust contribution only)")    
Th_integral_values_c, U_integral_values_c = integral_over_positions_Th_U(crust_grid, energy_array, grid_1d_size_crust, theta_12, delta_m_21_squared, A_Th_c, A_U_c, rho_c)
print("done! moving on")


# The Mantle layering script is kind of a mess, especially when calculating things with constant P_ee, but it's fine ... I will have to rewrite this whole repo at some point and organize things nicely, but that day is not today. For now, I just want to see if splitting the layers into more sublayers makes a difference in the final plots

# In[13]:


#make plots
print("making plots")
#Thorium
plt.plot(energy_array, Th_integral_values_c, marker='o', linestyle='-', color='b')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Thorium')
plt.savefig('Integral_over_emission_position_Thorium_standard_oscillation_parameters.pdf', format='pdf')
plt.close()

#Uranium
plt.plot(energy_array, U_integral_values_c, marker='o', linestyle='-', color='r')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Uranium')
plt.savefig('Integral_over_emission_position_Uranium_standard_oscillation_parameters.pdf', format='pdf')
plt.close()

#Both together

plt.plot(energy_array, Th_integral_values_c, marker='o', linestyle='-', color='b', label='Thorium')
plt.plot(energy_array, U_integral_values_c, marker='o', linestyle='-', color='r', label='Uranium')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position')
plt.legend()
plt.savefig('Integral_over_emission_position_standard_oscillation_parameters.pdf', format='pdf')
plt.close()


# In[14]:


def integral_over_positions_Th_U_constant_P_ee(points_array, energy_array, grid_1d_size, A_Th, A_U, rho):
    dV = grid_1d_size**3
    
    relative_distance_array = calc_relative_dist(points_array)
    P_ee_mid = 0.521
    P_ee_stdev = 0.072
    P_ee_low = P_ee_mid - P_ee_stdev
    P_ee_high = P_ee_mid + P_ee_stdev
    P_ee_array_mid = np.full((len(energy_array), len(points_array)), P_ee_mid)
    P_ee_array_low = np.full((len(energy_array), len(points_array)), P_ee_low)
    P_ee_array_high = np.full((len(energy_array), len(points_array)), P_ee_high)
    
    
    # Compute sum_Th
    sum_mid_Th = np.sum(P_ee_array_mid * ((A_Th * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    sum_low_Th = np.sum(P_ee_array_low * ((A_Th * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    sum_high_Th = np.sum(P_ee_array_high * ((A_Th * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    
    # Compute sum_U
    sum_mid_U = np.sum(P_ee_array_mid * ((A_U * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    sum_low_U = np.sum(P_ee_array_low * ((A_U * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)
    sum_high_U = np.sum(P_ee_array_high * ((A_U * rho) / (4 * np.pi * (relative_distance_array**2)))[np.newaxis, :] * dV, axis=1)

    return sum_mid_Th, sum_mid_U, sum_low_Th, sum_low_U, sum_high_Th, sum_high_U


# In[15]:


print("computing integral values for standard P_ee (crust contribution only")
Th_integral_values_constant_P_ee_mid_c, U_integral_values_constant_P_ee_mid_c, Th_integral_values_constant_P_ee_low_c, U_integral_values_constant_P_ee_low_c, Th_integral_values_constant_P_ee_high_c, U_integral_values_constant_P_ee_high_c = integral_over_positions_Th_U_constant_P_ee (crust_grid, energy_array, grid_1d_size_crust, A_Th_c, A_U_c, rho_c)
print("done! moving on")


# In[16]:


#make plots, just for integrals with constant P_ee
print("making plots")
#Thorium
plt.plot(energy_array, Th_integral_values_constant_P_ee_mid_c, marker='o', linestyle='-', color='b')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Thorium')
plt.close()

#Uranium
plt.plot(energy_array, U_integral_values_constant_P_ee_mid_c, marker='o', linestyle='-', color='r')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Uranium')
plt.close()

#Both together

plt.plot(energy_array, Th_integral_values_constant_P_ee_mid_c, marker='o', linestyle='-', color='b', label='Thorium')
plt.plot(energy_array, U_integral_values_constant_P_ee_mid_c, marker='o', linestyle='-', color='r', label='Uranium')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position')
plt.legend()
plt.close()
#make plots to compare integral for constant P_ee and non-constant(dependent on energy and oscillation parameters)

#Thorium
plt.plot(energy_array, Th_integral_values_constant_P_ee_mid_c, marker='o', linestyle='-', color='b', label='constant P_ee')
plt.plot(energy_array, Th_integral_values_c, marker='*', linestyle='-', color='b', label='non-constant P_ee, standard osc params')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Thorium')
plt.legend()
plt.savefig('Thorium_Integral_standard_osc_params_vs_constant_P_ee.pdf', format='pdf')
plt.close()

#Uranium
plt.plot(energy_array, U_integral_values_constant_P_ee_mid_c, marker='o', linestyle='-', color='r')
plt.plot(energy_array, U_integral_values_c, marker='*', linestyle='-', color='r', label = 'non-constant P_ee, standard osc params')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Uranium')
plt.legend()
plt.savefig('Uranium_Integral_standard_osc_params_vs_constant_P_ee.pdf', format='pdf')
plt.close()


# In[17]:


def sigma_IBD(energy_array):
    # optimized with numpy
    
    m_e = 0.511 #MeV
    m_p = 938 #MeV
    m_n = 941 #MeV
    E_th = 1.8 #MeV
    
    sigma = ((energy_array - E_th + m_e)**2) * ((1 - (m_e)**2/((energy_array - E_th + m_e)**2))**(1/2))
    
    return sigma
#all these + sources in Earth model more bins -3 (for example)


# In[18]:


print("setting lambda and mu values")

lambda_U = 4.916
lambda_Th = 1.563
mu_U = 235
mu_Th = 232


# In[19]:


#get fluxes
print("getting emission fluxes")
energy_array_U = []
dn_dE_U = []

with open('U238_spectrum.txt', 'r') as file:
    for line in file:
        # Split each line into columns
        columns = line.split()

        # Convert the elements to float and append to arrays
        energy_array_U.append(float(columns[0]))
        dn_dE_U.append(float(columns[1]))

# Scale down all energies by a factor of 1000
energy_array_U = np.array(energy_array_U) / 1000
dn_dE_U = np.array(dn_dE_U)

plt.plot(energy_array_U, dn_dE_U)
plt.xlabel('E_nu [MeV]')
plt.yscale('log')
plt.ylabel('Intensity (arbitrary units)')
plt.title('Energy spectrum of geonus from U238 decay')
# 
# Add shaded region between 1.8 MeV and 3.2 MeV
plt.axvspan(1.8, 3.2, alpha=0.3, color='gray')
# Enable minor ticks on x-axis
plt.minorticks_on()
plt.savefig("Emission.pdf", format='pdf')
plt.close()

print("done for Uranium, moving on to Thorium")

energy_array_Th = []
dn_dE_Th = []
with open('Th232_spectrum.txt', 'r') as file:
    for line in file:
        # Split each line into columns
        columns = line.split()

        # Convert the elements to float and append to arrays
        energy_array_Th.append(float(columns[0]))
        dn_dE_Th.append(float(columns[1]))

# Scale down all energies by a factor of 1000
energy_array_Th = np.array(energy_array_Th) / 1000
dn_dE_Th = np.array(dn_dE_Th)

plt.plot(energy_array_Th, dn_dE_Th)
plt.xlabel('$E_{\nu}$ [MeV]')
plt.yscale('log')
plt.ylabel('Intensity (some units, doesn\'t matter)')
plt.title('Energy spectrum of geonus from Th232 decay')
# # Add shaded region between 1.8 MeV and 3.2 MeV
plt.axvspan(1.8, 3.2, alpha=0.3, color='gray')
# # Enable minor ticks on x-axis
plt.minorticks_on()
plt.close()
# Plot U238 decay data (blue line)
plt.plot(energy_array_U, dn_dE_U, label='U238 decays', color='blue')
# 
# # Plot Th232 decay data (red line)
plt.plot(energy_array_Th, dn_dE_Th, label='Th232 decays', color='red')
# 
plt.xlabel('E_nu [MeV]')
plt.yscale('log')
plt.ylabel('Intensity (arbitrary units)')
plt.title('Energy spectrum of geonus')
# 
# # Add shaded region between 1.8 MeV and 3.3 MeV
plt.axvspan(1.8, 3.3, alpha=0.3, color='gray')
# 
# # Enable minor ticks on x-axis
plt.minorticks_on()
# 
plt.legend(loc='upper right')
# 
#plt.show()

plt.savefig("Emission_2.pdf", format='pdf')
plt.close()
def rebin_counts(initial_bins, counts_in_initial_bins, final_bin_midpoints):
    """
    Rebins counts data.

    Parameters:
    - initial_bins: array, bin edges of the initial data
    - counts_in_initial_bins: array, counts in each initial bin
    - final_bin_midpoints: array, midpoints of the final desired bins

    Returns:
    - counts_in_final_bins: array, counts in each final bin
    """

    # Calculate bin midpoints of the initial bins
    bin_midpoints = (initial_bins[:-1] + initial_bins[1:]) / 2

    # Use np.histogram to calculate counts in final bins
    counts_in_final_bins, _ = np.histogram(initial_bins, bins=np.concatenate([initial_bins, [2 * initial_bins[-1] - initial_bins[-2]]]), weights=counts_in_initial_bins)

    # Interpolate the counts to the final bin midpoints
    counts_in_final_bins = np.interp(final_bin_midpoints, bin_midpoints, counts_in_final_bins[:-1])

    return counts_in_final_bins

print("rebin to match energy array")

dn_dE_rebinned_U = rebin_counts(energy_array_U, dn_dE_U, energy_array)
dn_dE_rebinned_Th = rebin_counts(energy_array_Th, dn_dE_Th, energy_array)


# In[20]:


print("computing IBD cross section")
sigma = sigma_IBD(energy_array)


# Compute total fluxes coming from crust - same as Mantle layering:

# In[21]:


print("computing fluxes at detector (standard oscillation parameters, crust contribution only")
N_Th_c = ((lambda_Th)/(mu_Th)) * sigma * dn_dE_rebinned_Th * Th_integral_values_c
N_U_c = ((lambda_U)/(mu_U)) * sigma * dn_dE_rebinned_U * U_integral_values_c
   


# In[22]:


# Plot histogram for both
plt.step(energy_array, N_U_c + N_Th_c, where='mid', label='Total', color='green')
plt.step(energy_array, N_U_c, where='mid', label='U238 decays', color='blue')
plt.step(energy_array, N_Th_c, where='mid', label='Th232 decays', color='red')

plt.xlabel('E_nu [MeV]')
plt.yscale('log')
plt.ylabel('Expected counts (some units, doesn\'t matter)')
plt.title('Expected geonus')

# Set lower limit for y-axis to 10^-7
plt.ylim(bottom=6e-11)

# Enable minor ticks on x-axis
plt.minorticks_on()

# Add legend
plt.legend(loc='upper right')

plt.close()


# In[23]:


print("computing fluxes at detector (constant P_ee, crust contribution only")
N_Th_constant_P_ee_mid_c = ((lambda_Th)/(mu_Th)) * sigma * dn_dE_rebinned_Th * Th_integral_values_constant_P_ee_mid_c
N_U_constant_P_ee_mid_c = ((lambda_U)/(mu_U)) * sigma * dn_dE_rebinned_U * U_integral_values_constant_P_ee_mid_c
    
N_Th_constant_P_ee_low_c = ((lambda_Th)/(mu_Th)) * sigma * dn_dE_rebinned_Th * Th_integral_values_constant_P_ee_low_c
N_U_constant_P_ee_low_c = ((lambda_U)/(mu_U)) * sigma * dn_dE_rebinned_U * U_integral_values_constant_P_ee_low_c
    
N_Th_constant_P_ee_high_c = ((lambda_Th)/(mu_Th)) * sigma * dn_dE_rebinned_Th * Th_integral_values_constant_P_ee_high_c
N_U_constant_P_ee_high_c = ((lambda_U)/(mu_U)) * sigma * dn_dE_rebinned_U * U_integral_values_constant_P_ee_high_c
    


# In[24]:


# Plot histogram for both, constant P_ee only
plt.step(energy_array, N_U_constant_P_ee_mid_c + N_Th_constant_P_ee_mid_c, where='mid', label='Total, constant P_ee', color='green')
plt.step(energy_array, N_U_constant_P_ee_mid_c, where='mid', label='U238 decays', color='blue')
plt.step(energy_array, N_Th_constant_P_ee_mid_c, where='mid', label='Th232 decays', color='red')

plt.xlabel('E_nu [MeV]')
plt.yscale('log')
plt.ylabel('Expected counts (some units, doesn\'t matter)')
plt.title('Expected geonus')

# Set lower limit for y-axis to 10^-7
plt.ylim(bottom=6e-11)

# Enable minor ticks on x-axis
plt.minorticks_on()

# Add legend
plt.legend(loc='upper right')

plt.close()
#plot to compare total for constant P_ee vs non-constant P_ee with standard osc parameters

plt.step(energy_array, N_U_constant_P_ee_mid_c + N_Th_constant_P_ee_mid_c, where='mid', label='Total, constant P_ee', color='green')
plt.step(energy_array, N_U_c + N_Th_c, where='mid', label='Total, non-constant P_ee', color='lime')

plt.xlabel('E_nu [MeV]')
plt.yscale('log')
plt.ylabel('Expected counts (some units, doesn\'t matter)')
plt.title('Expected geonus')

# Set lower limit for y-axis to 10^-7
plt.ylim(bottom=6e-11)

# Enable minor ticks on x-axis
plt.minorticks_on()

# Add legend
plt.legend(loc='upper right')
plt.savefig('Expected_counts_standard_params_vs_constant_P_ee.pdf', format='pdf')

plt.close()


plt.plot(energy_array, (N_U_constant_P_ee_mid_c + N_Th_constant_P_ee_mid_c) / (N_U_c + N_Th_c), label='ratio', color='green')
plt.xlabel('E_nu [MeV]')
plt.ylabel('ratio')
plt.title('Ratio_of_expected_geonus_const_P_ee_over_non-const')

# Set lower limit for y-axis to 10^-7
#plt.ylim(bottom=1e-12)
# Set lower limit for y-axis to 10^-7
plt.ylim(bottom=0.92, top=1.2)

# Enable minor ticks on x-axis
plt.minorticks_on()

# Add legend
plt.legend(loc='upper right')
plt.savefig('Ratio_of_expected_geonus_standard_params_vs_constant_P_ee.pdf', format='pdf')

plt.close()
# we did this for the crust, now want to do this for the mantle as well
# mantle grid too big, restrict distances
# adjust size as required


# Now, everything so far MUST be the same, because we didn't change anything about the crust. If everything so far is NOT, the same, something is INCREDIBLY wrong. I will run both up until this point to check that everything is indeed identical
# 
# 

# Everything is indeed identical so far: the next cell (CLM calculation) is also copied; then, we have to modify the calculation for the DM and EM bits

# In[ ]:


print("computing integrals for standard oscillation parameters, CLM contribution only")

Th_integral_values_CLM, U_integral_values_CLM = integral_over_positions_Th_U(CLM_grid, energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_CLM, A_U_CLM, rho_CLM)


# In[ ]:


print("computing integrals for standard oscillation parameters, DM contribution only")

Th_integral_values_DM1, U_integral_values_DM1 = integral_over_positions_Th_U(DM_grids[0], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM2, U_integral_values_DM2 = integral_over_positions_Th_U(DM_grids[1], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM3, U_integral_values_DM3 = integral_over_positions_Th_U(DM_grids[2], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM4, U_integral_values_DM4 = integral_over_positions_Th_U(DM_grids[3], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM5, U_integral_values_DM5 = integral_over_positions_Th_U(DM_grids[4], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM6, U_integral_values_DM6 = integral_over_positions_Th_U(DM_grids[5], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM7, U_integral_values_DM7 = integral_over_positions_Th_U(DM_grids[6], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM8, U_integral_values_DM8 = integral_over_positions_Th_U(DM_grids[7], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM9, U_integral_values_DM9 = integral_over_positions_Th_U(DM_grids[8], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM10, U_integral_values_DM10 = integral_over_positions_Th_U(DM_grids[9], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM11, U_integral_values_DM11 = integral_over_positions_Th_U(DM_grids[10], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM12, U_integral_values_DM12 = integral_over_positions_Th_U(DM_grids[11], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM13, U_integral_values_DM13 = integral_over_positions_Th_U(DM_grids[12], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM14, U_integral_values_DM14 = integral_over_positions_Th_U(DM_grids[13], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM15, U_integral_values_DM15 = integral_over_positions_Th_U(DM_grids[14], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM16, U_integral_values_DM16 = integral_over_positions_Th_U(DM_grids[15], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM17, U_integral_values_DM17 = integral_over_positions_Th_U(DM_grids[16], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM18, U_integral_values_DM18 = integral_over_positions_Th_U(DM_grids[17], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM19, U_integral_values_DM19 = integral_over_positions_Th_U(DM_grids[18], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_DM = (
    Th_integral_values_DM1 + Th_integral_values_DM2 + Th_integral_values_DM3 + 
    Th_integral_values_DM4 + Th_integral_values_DM5 + Th_integral_values_DM6 + 
    Th_integral_values_DM7 + Th_integral_values_DM8 + Th_integral_values_DM9 + 
    Th_integral_values_DM10 + Th_integral_values_DM11 + Th_integral_values_DM12 + 
    Th_integral_values_DM13 + Th_integral_values_DM14 + Th_integral_values_DM15 + 
    Th_integral_values_DM16 + Th_integral_values_DM17 + Th_integral_values_DM18 + 
    Th_integral_values_DM19
)

U_integral_values_DM = (
    U_integral_values_DM1 + U_integral_values_DM2 + U_integral_values_DM3 + 
    U_integral_values_DM4 + U_integral_values_DM5 + U_integral_values_DM6 + 
    U_integral_values_DM7 + U_integral_values_DM8 + U_integral_values_DM9 + 
    U_integral_values_DM10 + U_integral_values_DM11 + U_integral_values_DM12 + 
    U_integral_values_DM13 + U_integral_values_DM14 + U_integral_values_DM15 + 
    U_integral_values_DM16 + U_integral_values_DM17 + U_integral_values_DM18 + 
    U_integral_values_DM19
)


# The thing above took half a second longer (5s 353 ms instead of 4s 851ms) but seems good so far! Let's keep going

# In[ ]:


print("computing integrals for standard oscillation parameters, EM contribution only")

Th_integral_values_EM1, U_integral_values_EM1 = integral_over_positions_Th_U(EM_grids[0], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_EM2, U_integral_values_EM2 = integral_over_positions_Th_U(EM_grids[1], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_EM3, U_integral_values_EM3 = integral_over_positions_Th_U(EM_grids[2], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_EM4, U_integral_values_EM4 = integral_over_positions_Th_U(EM_grids[3], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_EM5, U_integral_values_EM5 = integral_over_positions_Th_U(EM_grids[4], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_EM6, U_integral_values_EM6 = integral_over_positions_Th_U(EM_grids[5], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_EM7, U_integral_values_EM7 = integral_over_positions_Th_U(EM_grids[6], energy_array, grid_1d_size_mantle, theta_12, delta_m_21_squared, A_Th_EM, A_U_EM, rho_EM)



Th_integral_values_EM = (
    Th_integral_values_EM1 + Th_integral_values_EM2 + Th_integral_values_EM3 + 
    Th_integral_values_EM4 + Th_integral_values_EM5 + Th_integral_values_EM6 + 
    Th_integral_values_EM7
)

U_integral_values_EM = (
    U_integral_values_EM1 + U_integral_values_EM2 + U_integral_values_EM3 + 
    U_integral_values_EM4 + U_integral_values_EM5 + U_integral_values_EM6 + 
    U_integral_values_EM7
)



# The cell above took 2s 704ms instead of 988ms. Again, reasonable difference; All the next cells should be the same, so we should be ready for the final comparison!

# In[ ]:


print(" computing total contribution ")
Th_integral_values_m = Th_integral_values_CLM + Th_integral_values_EM + Th_integral_values_DM
U_integral_values_m = U_integral_values_CLM + U_integral_values_EM + U_integral_values_DM


# Ah, except the constant ones which will be a pain in the ass .... 

# In[ ]:


print("computing integrals for constant P_ee, CLM contribution only")
Th_integral_values_constant_P_ee_mid_CLM, U_integral_values_constant_P_ee_mid_CLM, Th_integral_values_constant_P_ee_low_CLM, U_integral_values_constant_P_ee_low_CLM, Th_integral_values_constant_P_ee_high_CLM, U_integral_values_constant_P_ee_high_CLM = integral_over_positions_Th_U_constant_P_ee (CLM_grid, energy_array, grid_1d_size_mantle, A_Th_CLM, A_U_CLM, rho_CLM)


# In[ ]:


print("computing integrals for constant P_ee, DM contribution only")

Th_integral_values_constant_P_ee_mid_DM1, U_integral_values_constant_P_ee_mid_DM1, Th_integral_values_constant_P_ee_low_DM1, U_integral_values_constant_P_ee_low_DM1, Th_integral_values_constant_P_ee_high_DM1, U_integral_values_constant_P_ee_high_DM1 = integral_over_positions_Th_U_constant_P_ee(DM_grids[0], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM2, U_integral_values_constant_P_ee_mid_DM2, Th_integral_values_constant_P_ee_low_DM2, U_integral_values_constant_P_ee_low_DM2, Th_integral_values_constant_P_ee_high_DM2, U_integral_values_constant_P_ee_high_DM2 = integral_over_positions_Th_U_constant_P_ee(DM_grids[1], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM3, U_integral_values_constant_P_ee_mid_DM3, Th_integral_values_constant_P_ee_low_DM3, U_integral_values_constant_P_ee_low_DM3, Th_integral_values_constant_P_ee_high_DM3, U_integral_values_constant_P_ee_high_DM3 = integral_over_positions_Th_U_constant_P_ee(DM_grids[2], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM4, U_integral_values_constant_P_ee_mid_DM4, Th_integral_values_constant_P_ee_low_DM4, U_integral_values_constant_P_ee_low_DM4, Th_integral_values_constant_P_ee_high_DM4, U_integral_values_constant_P_ee_high_DM4 = integral_over_positions_Th_U_constant_P_ee(DM_grids[3], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM5, U_integral_values_constant_P_ee_mid_DM5, Th_integral_values_constant_P_ee_low_DM5, U_integral_values_constant_P_ee_low_DM5, Th_integral_values_constant_P_ee_high_DM5, U_integral_values_constant_P_ee_high_DM5 = integral_over_positions_Th_U_constant_P_ee(DM_grids[4], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM6, U_integral_values_constant_P_ee_mid_DM6, Th_integral_values_constant_P_ee_low_DM6, U_integral_values_constant_P_ee_low_DM6, Th_integral_values_constant_P_ee_high_DM6, U_integral_values_constant_P_ee_high_DM6 = integral_over_positions_Th_U_constant_P_ee(DM_grids[5], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM7, U_integral_values_constant_P_ee_mid_DM7, Th_integral_values_constant_P_ee_low_DM7, U_integral_values_constant_P_ee_low_DM7, Th_integral_values_constant_P_ee_high_DM7, U_integral_values_constant_P_ee_high_DM7 = integral_over_positions_Th_U_constant_P_ee(DM_grids[6], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM8, U_integral_values_constant_P_ee_mid_DM8, Th_integral_values_constant_P_ee_low_DM8, U_integral_values_constant_P_ee_low_DM8, Th_integral_values_constant_P_ee_high_DM8, U_integral_values_constant_P_ee_high_DM8 = integral_over_positions_Th_U_constant_P_ee(DM_grids[7], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM9, U_integral_values_constant_P_ee_mid_DM9, Th_integral_values_constant_P_ee_low_DM9, U_integral_values_constant_P_ee_low_DM9, Th_integral_values_constant_P_ee_high_DM9, U_integral_values_constant_P_ee_high_DM9 = integral_over_positions_Th_U_constant_P_ee(DM_grids[8], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM10, U_integral_values_constant_P_ee_mid_DM10, Th_integral_values_constant_P_ee_low_DM10, U_integral_values_constant_P_ee_low_DM10, Th_integral_values_constant_P_ee_high_DM10, U_integral_values_constant_P_ee_high_DM10 = integral_over_positions_Th_U_constant_P_ee(DM_grids[9], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM11, U_integral_values_constant_P_ee_mid_DM11, Th_integral_values_constant_P_ee_low_DM11, U_integral_values_constant_P_ee_low_DM11, Th_integral_values_constant_P_ee_high_DM11, U_integral_values_constant_P_ee_high_DM11 = integral_over_positions_Th_U_constant_P_ee(DM_grids[10], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM12, U_integral_values_constant_P_ee_mid_DM12, Th_integral_values_constant_P_ee_low_DM12, U_integral_values_constant_P_ee_low_DM12, Th_integral_values_constant_P_ee_high_DM12, U_integral_values_constant_P_ee_high_DM12 = integral_over_positions_Th_U_constant_P_ee(DM_grids[11], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM13, U_integral_values_constant_P_ee_mid_DM13, Th_integral_values_constant_P_ee_low_DM13, U_integral_values_constant_P_ee_low_DM13, Th_integral_values_constant_P_ee_high_DM13, U_integral_values_constant_P_ee_high_DM13 = integral_over_positions_Th_U_constant_P_ee(DM_grids[12], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM14, U_integral_values_constant_P_ee_mid_DM14, Th_integral_values_constant_P_ee_low_DM14, U_integral_values_constant_P_ee_low_DM14, Th_integral_values_constant_P_ee_high_DM14, U_integral_values_constant_P_ee_high_DM14 = integral_over_positions_Th_U_constant_P_ee(DM_grids[13], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM15, U_integral_values_constant_P_ee_mid_DM15, Th_integral_values_constant_P_ee_low_DM15, U_integral_values_constant_P_ee_low_DM15, Th_integral_values_constant_P_ee_high_DM15, U_integral_values_constant_P_ee_high_DM15 = integral_over_positions_Th_U_constant_P_ee(DM_grids[14], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM16, U_integral_values_constant_P_ee_mid_DM16, Th_integral_values_constant_P_ee_low_DM16, U_integral_values_constant_P_ee_low_DM16, Th_integral_values_constant_P_ee_high_DM16, U_integral_values_constant_P_ee_high_DM16 = integral_over_positions_Th_U_constant_P_ee(DM_grids[15], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM17, U_integral_values_constant_P_ee_mid_DM17, Th_integral_values_constant_P_ee_low_DM17, U_integral_values_constant_P_ee_low_DM17, Th_integral_values_constant_P_ee_high_DM17, U_integral_values_constant_P_ee_high_DM17 = integral_over_positions_Th_U_constant_P_ee(DM_grids[16], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM18, U_integral_values_constant_P_ee_mid_DM18, Th_integral_values_constant_P_ee_low_DM18, U_integral_values_constant_P_ee_low_DM18, Th_integral_values_constant_P_ee_high_DM18, U_integral_values_constant_P_ee_high_DM18 = integral_over_positions_Th_U_constant_P_ee(DM_grids[17], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)

Th_integral_values_constant_P_ee_mid_DM19, U_integral_values_constant_P_ee_mid_DM19, Th_integral_values_constant_P_ee_low_DM19, U_integral_values_constant_P_ee_low_DM19, Th_integral_values_constant_P_ee_high_DM19, U_integral_values_constant_P_ee_high_DM19 = integral_over_positions_Th_U_constant_P_ee(DM_grids[18], energy_array, grid_1d_size_mantle, A_Th_DM, A_U_DM, rho_DM)


Th_integral_values_constant_P_ee_mid_DM = (
    Th_integral_values_constant_P_ee_mid_DM1 + Th_integral_values_constant_P_ee_mid_DM2 + 
    Th_integral_values_constant_P_ee_mid_DM3 + Th_integral_values_constant_P_ee_mid_DM4 + 
    Th_integral_values_constant_P_ee_mid_DM5 + Th_integral_values_constant_P_ee_mid_DM6 + 
    Th_integral_values_constant_P_ee_mid_DM7 + Th_integral_values_constant_P_ee_mid_DM8 + 
    Th_integral_values_constant_P_ee_mid_DM9 + Th_integral_values_constant_P_ee_mid_DM10 + 
    Th_integral_values_constant_P_ee_mid_DM11 + Th_integral_values_constant_P_ee_mid_DM12 + 
    Th_integral_values_constant_P_ee_mid_DM13 + Th_integral_values_constant_P_ee_mid_DM14 + 
    Th_integral_values_constant_P_ee_mid_DM15 + Th_integral_values_constant_P_ee_mid_DM16 + 
    Th_integral_values_constant_P_ee_mid_DM17 + Th_integral_values_constant_P_ee_mid_DM18 + 
    Th_integral_values_constant_P_ee_mid_DM19
)

Th_integral_values_constant_P_ee_low_DM = (
    Th_integral_values_constant_P_ee_low_DM1 + Th_integral_values_constant_P_ee_low_DM2 + 
    Th_integral_values_constant_P_ee_low_DM3 + Th_integral_values_constant_P_ee_low_DM4 + 
    Th_integral_values_constant_P_ee_low_DM5 + Th_integral_values_constant_P_ee_low_DM6 + 
    Th_integral_values_constant_P_ee_low_DM7 + Th_integral_values_constant_P_ee_low_DM8 + 
    Th_integral_values_constant_P_ee_low_DM9 + Th_integral_values_constant_P_ee_low_DM10 + 
    Th_integral_values_constant_P_ee_low_DM11 + Th_integral_values_constant_P_ee_low_DM12 + 
    Th_integral_values_constant_P_ee_low_DM13 + Th_integral_values_constant_P_ee_low_DM14 + 
    Th_integral_values_constant_P_ee_low_DM15 + Th_integral_values_constant_P_ee_low_DM16 + 
    Th_integral_values_constant_P_ee_low_DM17 + Th_integral_values_constant_P_ee_low_DM18 + 
    Th_integral_values_constant_P_ee_low_DM19
)

Th_integral_values_constant_P_ee_high_DM = (
    Th_integral_values_constant_P_ee_high_DM1 + Th_integral_values_constant_P_ee_high_DM2 + 
    Th_integral_values_constant_P_ee_high_DM3 + Th_integral_values_constant_P_ee_high_DM4 + 
    Th_integral_values_constant_P_ee_high_DM5 + Th_integral_values_constant_P_ee_high_DM6 + 
    Th_integral_values_constant_P_ee_high_DM7 + Th_integral_values_constant_P_ee_high_DM8 + 
    Th_integral_values_constant_P_ee_high_DM9 + Th_integral_values_constant_P_ee_high_DM10 + 
    Th_integral_values_constant_P_ee_high_DM11 + Th_integral_values_constant_P_ee_high_DM12 + 
    Th_integral_values_constant_P_ee_high_DM13 + Th_integral_values_constant_P_ee_high_DM14 + 
    Th_integral_values_constant_P_ee_high_DM15 + Th_integral_values_constant_P_ee_high_DM16 + 
    Th_integral_values_constant_P_ee_high_DM17 + Th_integral_values_constant_P_ee_high_DM18 + 
    Th_integral_values_constant_P_ee_high_DM19
)

U_integral_values_constant_P_ee_mid_DM = (
    U_integral_values_constant_P_ee_mid_DM1 + U_integral_values_constant_P_ee_mid_DM2 + 
    U_integral_values_constant_P_ee_mid_DM3 + U_integral_values_constant_P_ee_mid_DM4 + 
    U_integral_values_constant_P_ee_mid_DM5 + U_integral_values_constant_P_ee_mid_DM6 + 
    U_integral_values_constant_P_ee_mid_DM7 + U_integral_values_constant_P_ee_mid_DM8 + 
    U_integral_values_constant_P_ee_mid_DM9 + U_integral_values_constant_P_ee_mid_DM10 + 
    U_integral_values_constant_P_ee_mid_DM11 + U_integral_values_constant_P_ee_mid_DM12 + 
    U_integral_values_constant_P_ee_mid_DM13 + U_integral_values_constant_P_ee_mid_DM14 + 
    U_integral_values_constant_P_ee_mid_DM15 + U_integral_values_constant_P_ee_mid_DM16 + 
    U_integral_values_constant_P_ee_mid_DM17 + U_integral_values_constant_P_ee_mid_DM18 + 
    U_integral_values_constant_P_ee_mid_DM19
)

U_integral_values_constant_P_ee_low_DM = (
    U_integral_values_constant_P_ee_low_DM1 + U_integral_values_constant_P_ee_low_DM2 + 
    U_integral_values_constant_P_ee_low_DM3 + U_integral_values_constant_P_ee_low_DM4 + 
    U_integral_values_constant_P_ee_low_DM5 + U_integral_values_constant_P_ee_low_DM6 + 
    U_integral_values_constant_P_ee_low_DM7 + U_integral_values_constant_P_ee_low_DM8 + 
    U_integral_values_constant_P_ee_low_DM9 + U_integral_values_constant_P_ee_low_DM10 + 
    U_integral_values_constant_P_ee_low_DM11 + U_integral_values_constant_P_ee_low_DM12 + 
    U_integral_values_constant_P_ee_low_DM13 + U_integral_values_constant_P_ee_low_DM14 + 
    U_integral_values_constant_P_ee_low_DM15 + U_integral_values_constant_P_ee_low_DM16 + 
    U_integral_values_constant_P_ee_low_DM17 + U_integral_values_constant_P_ee_low_DM18 + 
    U_integral_values_constant_P_ee_low_DM19
)

U_integral_values_constant_P_ee_high_DM = (
    U_integral_values_constant_P_ee_high_DM1 + U_integral_values_constant_P_ee_high_DM2 + 
    U_integral_values_constant_P_ee_high_DM3 + U_integral_values_constant_P_ee_high_DM4 + 
    U_integral_values_constant_P_ee_high_DM5 + U_integral_values_constant_P_ee_high_DM6 + 
    U_integral_values_constant_P_ee_high_DM7 + U_integral_values_constant_P_ee_high_DM8 + 
    U_integral_values_constant_P_ee_high_DM9 + U_integral_values_constant_P_ee_high_DM10 + 
    U_integral_values_constant_P_ee_high_DM11 + U_integral_values_constant_P_ee_high_DM12 + 
    U_integral_values_constant_P_ee_high_DM13 + U_integral_values_constant_P_ee_high_DM14 + 
    U_integral_values_constant_P_ee_high_DM15 + U_integral_values_constant_P_ee_high_DM16 + 
    U_integral_values_constant_P_ee_high_DM17 + U_integral_values_constant_P_ee_high_DM18 + 
    U_integral_values_constant_P_ee_high_DM19
)



# The times for the cell above and its equivalent in Mantle Layering are very very similar, which is a good sign. Now EM:

# In[ ]:


print("computing integrals for constant P_ee, EM contribution only")

Th_integral_values_constant_P_ee_mid_EM1, U_integral_values_constant_P_ee_mid_EM1, Th_integral_values_constant_P_ee_low_EM1, U_integral_values_constant_P_ee_low_EM1, Th_integral_values_constant_P_ee_high_EM1, U_integral_values_constant_P_ee_high_EM1 = integral_over_positions_Th_U_constant_P_ee(EM_grids[0], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_constant_P_ee_mid_EM2, U_integral_values_constant_P_ee_mid_EM2, Th_integral_values_constant_P_ee_low_EM2, U_integral_values_constant_P_ee_low_EM2, Th_integral_values_constant_P_ee_high_EM2, U_integral_values_constant_P_ee_high_EM2 = integral_over_positions_Th_U_constant_P_ee(EM_grids[1], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_constant_P_ee_mid_EM3, U_integral_values_constant_P_ee_mid_EM3, Th_integral_values_constant_P_ee_low_EM3, U_integral_values_constant_P_ee_low_EM3, Th_integral_values_constant_P_ee_high_EM3, U_integral_values_constant_P_ee_high_EM3 = integral_over_positions_Th_U_constant_P_ee(EM_grids[2], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_constant_P_ee_mid_EM4, U_integral_values_constant_P_ee_mid_EM4, Th_integral_values_constant_P_ee_low_EM4, U_integral_values_constant_P_ee_low_EM4, Th_integral_values_constant_P_ee_high_EM4, U_integral_values_constant_P_ee_high_EM4 = integral_over_positions_Th_U_constant_P_ee(EM_grids[3], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_constant_P_ee_mid_EM5, U_integral_values_constant_P_ee_mid_EM5, Th_integral_values_constant_P_ee_low_EM5, U_integral_values_constant_P_ee_low_EM5, Th_integral_values_constant_P_ee_high_EM5, U_integral_values_constant_P_ee_high_EM5 = integral_over_positions_Th_U_constant_P_ee(EM_grids[4], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_constant_P_ee_mid_EM6, U_integral_values_constant_P_ee_mid_EM6, Th_integral_values_constant_P_ee_low_EM6, U_integral_values_constant_P_ee_low_EM6, Th_integral_values_constant_P_ee_high_EM6, U_integral_values_constant_P_ee_high_EM6 = integral_over_positions_Th_U_constant_P_ee(EM_grids[5], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)

Th_integral_values_constant_P_ee_mid_EM7, U_integral_values_constant_P_ee_mid_EM7, Th_integral_values_constant_P_ee_low_EM7, U_integral_values_constant_P_ee_low_EM7, Th_integral_values_constant_P_ee_high_EM7, U_integral_values_constant_P_ee_high_EM7 = integral_over_positions_Th_U_constant_P_ee(EM_grids[6], energy_array, grid_1d_size_mantle, A_Th_EM, A_U_EM, rho_EM)


Th_integral_values_constant_P_ee_mid_EM = (
    Th_integral_values_constant_P_ee_mid_EM1 + Th_integral_values_constant_P_ee_mid_EM2 + 
    Th_integral_values_constant_P_ee_mid_EM3 + Th_integral_values_constant_P_ee_mid_EM4 + 
    Th_integral_values_constant_P_ee_mid_EM5 + Th_integral_values_constant_P_ee_mid_EM6 + 
    Th_integral_values_constant_P_ee_mid_EM7
)

Th_integral_values_constant_P_ee_low_EM = (
    Th_integral_values_constant_P_ee_low_EM1 + Th_integral_values_constant_P_ee_low_EM2 + 
    Th_integral_values_constant_P_ee_low_EM3 + Th_integral_values_constant_P_ee_low_EM4 + 
    Th_integral_values_constant_P_ee_low_EM5 + Th_integral_values_constant_P_ee_low_EM6 + 
    Th_integral_values_constant_P_ee_low_EM7
)

Th_integral_values_constant_P_ee_high_EM = (
    Th_integral_values_constant_P_ee_high_EM1 + Th_integral_values_constant_P_ee_high_EM2 + 
    Th_integral_values_constant_P_ee_high_EM3 + Th_integral_values_constant_P_ee_high_EM4 + 
    Th_integral_values_constant_P_ee_high_EM5 + Th_integral_values_constant_P_ee_high_EM6 + 
    Th_integral_values_constant_P_ee_high_EM7
)

U_integral_values_constant_P_ee_mid_EM = (
    U_integral_values_constant_P_ee_mid_EM1 + U_integral_values_constant_P_ee_mid_EM2 + 
    U_integral_values_constant_P_ee_mid_EM3 + U_integral_values_constant_P_ee_mid_EM4 + 
    U_integral_values_constant_P_ee_mid_EM5 + U_integral_values_constant_P_ee_mid_EM6 + 
    U_integral_values_constant_P_ee_mid_EM7
)

U_integral_values_constant_P_ee_low_EM = (
    U_integral_values_constant_P_ee_low_EM1 + U_integral_values_constant_P_ee_low_EM2 + 
    U_integral_values_constant_P_ee_low_EM3 + U_integral_values_constant_P_ee_low_EM4 + 
    U_integral_values_constant_P_ee_low_EM5 + U_integral_values_constant_P_ee_low_EM6 + 
    U_integral_values_constant_P_ee_low_EM7
)

U_integral_values_constant_P_ee_high_EM = (
    U_integral_values_constant_P_ee_high_EM1 + U_integral_values_constant_P_ee_high_EM2 + 
    U_integral_values_constant_P_ee_high_EM3 + U_integral_values_constant_P_ee_high_EM4 + 
    U_integral_values_constant_P_ee_high_EM5 + U_integral_values_constant_P_ee_high_EM6 + 
    U_integral_values_constant_P_ee_high_EM7
)


# This one took 1s 519ms instead of 515ms but still reasonable. The next cell just adds up the contributions from the big layers so it should all be the same; NOW (actually this time) we can check whether all the plots match

# In[ ]:


print(" computing total contribution ")

Th_integral_values_constant_P_ee_mid_m = Th_integral_values_constant_P_ee_mid_CLM + Th_integral_values_constant_P_ee_mid_DM + Th_integral_values_constant_P_ee_mid_EM
Th_integral_values_constant_P_ee_low_m = Th_integral_values_constant_P_ee_low_CLM + Th_integral_values_constant_P_ee_low_DM + Th_integral_values_constant_P_ee_low_EM
Th_integral_values_constant_P_ee_high_m = Th_integral_values_constant_P_ee_high_CLM + Th_integral_values_constant_P_ee_high_DM + Th_integral_values_constant_P_ee_high_EM

U_integral_values_constant_P_ee_mid_m = U_integral_values_constant_P_ee_mid_CLM + U_integral_values_constant_P_ee_mid_DM + U_integral_values_constant_P_ee_mid_EM
U_integral_values_constant_P_ee_low_m = U_integral_values_constant_P_ee_low_CLM + U_integral_values_constant_P_ee_low_DM + U_integral_values_constant_P_ee_low_EM
U_integral_values_constant_P_ee_high_m = U_integral_values_constant_P_ee_high_CLM + U_integral_values_constant_P_ee_high_DM + U_integral_values_constant_P_ee_high_EM


# In[ ]:


#make plots to compare integral for constant P_ee and non-constant(dependent on energy and oscillation parameters)

#Thorium
plt.plot(energy_array, Th_integral_values_constant_P_ee_mid_m, marker='o', linestyle='-', color='b', label='constant P_ee')
plt.plot(energy_array, Th_integral_values_m, marker='*', linestyle='-', color='b', label='non-constant P_ee, standard osc params')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Thorium')
plt.legend()
plt.savefig('Thorium_Integral_standard_osc_params_vs_constant_P_ee.pdf', format='pdf')
plt.close()

#Uranium
plt.plot(energy_array, U_integral_values_constant_P_ee_mid_m, marker='o', linestyle='-', color='r')
plt.plot(energy_array, U_integral_values_m, marker='*', linestyle='-', color='r', label = 'non-constant P_ee, standard osc params')
plt.xlabel('Energy [MeV]')
plt.ylabel('Integral value')
plt.title('Integral over emission position, Uranium')
plt.legend()
plt.savefig('Uranium_Integral_standard_osc_params_vs_constant P_ee.pdf', format='pdf')
plt.close()


# THEY DON'T MATCH AT ALL!!!! FUCK!!!! what the hell is wrong with these? I don't get it ........... there must be something uper wrong with my method......

# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:




